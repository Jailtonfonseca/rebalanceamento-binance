from pathlib import Path
from pathlib import Path
from fastapi import FastAPI, Request
from fastapi.staticfiles import StaticFiles
from starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint
from starlette.responses import RedirectResponse

from app.api import v1_config, v1_rebalance, v1_status, v1_pages, v1_history, v1_arbitrage, v1_setup, v1_auth
from app.core.security import decode_access_token
from app.services.config_manager import config_manager, AppSettings
import logging
from app.services.scheduler import scheduler, setup_scheduler
from app.db.models import init_db
from app.utils.logging import setup_logging
from prometheus_fastapi_instrumentator import Instrumentator

from app.utils.middleware import RequestIDMiddleware, ErrorHandlingMiddleware

# Create the FastAPI app
app = FastAPI(
    title="Crypto Rebalancing Bot",
    description="A bot to automatically rebalance a crypto portfolio on Binance.",
    version="1.1.0",
)

# --- Middleware for Auth and First-Run Setup ---
class AuthMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next: RequestResponseEndpoint):
        settings = config_manager.get_settings()

        # Define paths that are always allowed (public)
        public_paths = [
            "/login",
            "/logout",
            "/setup",
            "/api/v1/setup",
            "/api/v1/auth/login",
            "/static",
            "/docs",
            "/redoc",
            "/openapi.json",
        ]
        is_public_path = any(request.url.path.startswith(p) for p in public_paths)

        # Add user to request state so it's available in templates
        request.state.user = None

        # 1. First-run setup check: If not configured, redirect to setup page
        if not settings.is_configured and not is_public_path:
            return RedirectResponse(url="/setup")

        # 2. Authentication check for protected routes
        if settings.is_configured and not is_public_path:
            token = request.cookies.get("access_token")
            if not token:
                return RedirectResponse(url="/login")

            username = decode_access_token(token)
            if not username or username != settings.admin_user:
                response = RedirectResponse(url="/login")
                response.delete_cookie("access_token")
                return response

            request.state.user = username

        response = await call_next(request)
        return response


# --- Prometheus Metrics ---
Instrumentator().instrument(app).expose(app)

# --- Middlewares ---
# The AuthMiddleware handles both setup and login checks.
app.add_middleware(AuthMiddleware)
app.add_middleware(RequestIDMiddleware)
app.add_middleware(ErrorHandlingMiddleware)

# --- Static files and Templates ---
# Define the path to the static directory relative to this file's location.
# main.py -> app -> src / web / static
STATIC_DIR = Path(__file__).parent.parent / "web" / "static"
app.mount("/static", StaticFiles(directory=STATIC_DIR), name="static")
# Some frontend assets (e.g. the service worker generated by the SPA build)
# are requested from the `/_static` path. Serving the same directory from this
# alias avoids noisy 404 log entries without duplicating files.
app.mount("/_static", StaticFiles(directory=STATIC_DIR), name="frontend-static")

# --- API Routers ---
app.include_router(v1_config.router, prefix="/api/v1")
app.include_router(v1_rebalance.router, prefix="/api/v1")
app.include_router(v1_status.router, prefix="/api/v1")
app.include_router(v1_history.router, prefix="/api/v1")
app.include_router(v1_arbitrage.router, prefix="/api/v1")
app.include_router(v1_setup.router, prefix="/api/v1")
app.include_router(v1_auth.router, prefix="/api/v1/auth")
# This router serves the HTML pages
app.include_router(v1_pages.router)


# --- Application Lifecycle Hooks ---


@app.on_event("startup")
async def startup_event():
    """
    Actions to perform on application startup.
    - Initialize database connections
    - Start the scheduler
    """
    setup_logging()
    # Ensure data directory and DB tables exist
    config_manager.config_path.parent.mkdir(exist_ok=True)
    init_db()

    # Start the scheduler if the strategy is periodic
    settings: AppSettings = config_manager.get_settings()
    if settings.strategy == "periodic":
        setup_scheduler(settings)
    logging.info("Application startup complete.")


@app.on_event("shutdown")
def shutdown_event():
    """
    Actions to perform on application shutdown.
    - Gracefully shut down the scheduler
    """
    logging.info("Application shutdown...")
    if scheduler.running:
        scheduler.shutdown()
    logging.info("Application shutdown complete.")
